3d1
ループが必要だが、親切なことにExampleにTime Warp を使ったループの仕方とループの抜け方で説明されているので同じことをするだけ。

3d2
最初は比較がなくて無理では？って思ったけどinputの範囲が小さいので、Aか-Aになる値を0から順番に試せばOK
途中A*sign(A)という解法も生まれたが最終的にはこの解法に帰ってきた。

3d3
3d2から-Aのルートなら*0-1、Aのルートなら*0+1、0なら0を出すようにすれば通る。
2日目起きてきたら奇数ならA%2が答えになるという天才的発想が生えていたのでそれを詰めていった。
ゼロ除算で死なないことに最後まで気づかなかった。

3d4
AとBをインクリメントし続けてもう一方になったら答え。
綺麗に並べたらbest解だったらしい

3d5
A*B/GCD(A,B)をするだけ。
0で割らないようにするのが難しかったが不要だった。

3d6
2から順番に試し割りするだけ。最初に書いたコードが順位が良かったからかなり長い間放置していたが、
他の問題が無理すぎてなんとなく数分でちょっと弄ったのがbest解になった。

3d7
n進数をスタックとみなして、入れ直しても変わらないなら回文。

3d8
3d7をループさせるだけだが、定数の10を書いていたところを更新しないといけないので、サブルーチンの記法（※）を編み出して、値の更新に利用した。
※ 周期を他より短くし、入力を#で比較して、実行時に入力を元の値に戻ようにすると、ほかのプログラムを動かさずに1回だけ実行される。

3d9
後ろから見て)が来たら+1、(が来たら-1する。途中で-1になったらNG。最後まで読んで0になってたらOK。

3d10
スタックを使えば終わりだったが、最初は（同じ括弧が連続した回数のスタック、スタックの先頭の文字）を頑張って更新していたため地獄だった。

3d11
盤面をメモリとして扱う方法を考えたが、readが大変なので諦め（実際に試すとプログラムがデカすぎてTLEするっぽい）
200*200の座標を訪れた回数を記録する100^(200*200)までの整数にエンコードする方法を試したが、最大ケースの20kステップでTLEするので没（リミットは1Mステップ）。
訪れた座標のスタックをもって、挿入時にO(N)かけて重複挿入しないようにする方針にすると整数が(200*200)^100までになって計算が早くなる？のか通った。
とりあえず通すのが目的だったので、これだけ配置を詰めたりはしていない。

3d12
一見ヤバそうだが、テイラー展開するだけ。
最初誤差全く許容されないと思っていろいろこねくり回していたが、誤差1許容されることに気づいたので、適当に99倍して最後に99割ればOKだった。
3回目スコアを2割ぐらい削ったのに順位が変わらなかったのを見て大きい問題を詰めるのはやめた。

efficiency5
efficiency13がなんか見てたら解けたと言われたので、やり始めた。
JS互換のフォーマットに変換するプログラムを使って、それをweb上のprettierに投げると読める形になるので読むと
10^6より大きい最小のメルセンヌ素数を求めているっぽいのでググって提出

efficiency6
同上

efficiency12
同上、だが出てきたプログラムが謎の関数（素因数分解して、合成数なら各素因数に対して*(p-1)/pして+1する）だったので頭の中は？？？だったがやってみたら通った。
