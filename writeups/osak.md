# 初日
とりあえずブラウザで動く通信機を書く。 
後々使いそうなのでRustでICFPのインタプリタを書く。ラムダに渡した式の束縛をきちんと管理できておらず無限にハマっていた。朝6時過ぎに完成したけど、その頃にはとっくにechoで式を評価させるテクが発見されていたので無用の長物になった。

Lambdamanは素直にコードゴルフでとっつきやすそうなので、こんなんRun Length Encodingに決まってるでしょ（コードゴルフ頻出）と思って簡易アセンブラを作り、(文字)(繰り返し数)のRLEでyuustiのgreedy解を縮めたらそこそこいい感じになる。それを叩き台に改良が進んでいき、最終的にはN要素の文字列辞書＋N進数エンコーディングで落ち着いた。

長いパターンを繰り返してだいたい全体が埋まる経路を作っておいて、取りこぼしはタイミングのいいところで拾いに行く感じにすると最強の辞書圧縮が完成するのでは……と思って議論するも、何を探索すればいいのかいまいちまとまらない（発想自体は最後に迷路を解くアイデアで役に立った）。そうこうしていたらamylaseがランダムウォークでlambdaman 4と5を解いたと言い出して一気に流れが変わる。

# lambdaman8
初期解：最初がDDLLUUUURRRR、一周するごとにDLURがそれぞれ2個ずつ増えていくのでナイーブに s1 + s2 + f (DD+s1+LL) (UU+s2+RR) の再帰を書く。200Bくらい？ 
壁にぶつかってもいいし、DLの最中にURが混ざらなければ変なことにはならないので s + (f (DL+s+UR)) の形の再帰にする。～138B
よく考えると最長部分を通れるパターンを1つ生成して適当に繰り返せばいい。累乗イディオムにすれば終了判定もいらないので再帰より短くできる。116B

# lambdaman16
ヒルベルト曲線というやつ。実装したことはなかったけど図を描いて考えると 
（左上を解く）→ちょっと下に移動→（左下を解く）→ちょっと右に移動→（右下を解く）→ちょっと上に移動→（右上を解く） 
という形になっていて、再帰的にやる部分では対角要素どうしが入れ替わったり入れ替わらなかったりする形になることが分かる。 
そのまま再帰で実装して264B。あとで縮めようと思ったらベストが乱数っぽい長さになっていて諦めた。

# lambdaman19
前に進む→（左手方向を解いて戻ってくる）→（右手方向を解いて戻ってくる）→（正面方向を解いて戻ってくる）→戻るの再帰。346B 
最初の実装では間違って深さを2倍にしてしまっていたけどそれでもなんか解けてた。 
これのベストは乱数じゃなさそうなのでもっとゴルフ頑張ってもよかったかも。

# 乱数
初期解：現在のステップ数と前回の乱数を渡すナイーブな再帰。160Bくらい？ 
→ ステップ数ではなく乱数の値で終了判定していいことに気付いて縮む。136B。確率が絡むインチキのつもりだったけど、乱数だと思っていたやつが実は巨大な巡回群だったのでインチキじゃなかった（ということを終わってから聞いた）。 
→ 定数の桁数を減らせればコードも縮むね……ということをyuustiと話していたらいつの間にかamylaseが実装していた。 
→ Lfはローカル変数の導入と等価なんだから、よく考えれば自己再帰はLf B$ vf vfで済むはずなのにYコンビネータはなんか明らかに長い……と思ってこの形にしたら普通に縮んだ。 
→ "solve lambdamanX " + (IF (終了条件) THEN "" ELSE "ULDR"[rand()%4] + (再帰))の形でTHENが空白なのなんか無駄っぽくない？と思って睨んでいたら、再帰の向きを逆順にすることで演算を節約できることに気付く。 (IF (終了条件) THEN "solve lambdamanX " ELSE (再帰) + "ULDR"[rand()%4]) の形になって縮む。この形だと再帰深さを変えると出力の先頭が変わるので探索がしにくいが、amylaseが頑張って探索を直す。でも巡回群なので実は逆元を掛けるだけで乱数を逆順にたどれたらしい（とiwiwiさんが言っていた）。

# 迷路
解ける乱数は見つかってなかったが、おおよそ解ける乱数というのは結構見つかっていたので、ランダムウォーク中の特定のステップでUUDDのような文字列を挟むことでランダムウォークを壊さずに好きなマスを通過させられるというアイデアをamylaseに話す。そしたら実装してくれた。
