English: [all.en.md](./all.en.md)

# amylase
## Lambdaman

LRDUに1文字使うのは明らかに損なのでエンコーディングすることを考える。実際割とうまく行ってまあまあ短くなるまでが初日。  
それ以降はなんのアイデアもなく1日以上停滞する。ランキングに情報理論的な限界を超える答えが続々現れて圧縮の方針では絶対に勝てないことがわかるので1から考え直して日曜の夜になんとかランダムウォークのアイデアにたどり着く。チームの皆さんにはかなり懐疑的な意見をもらったが試すのはすぐなのでやってみたらlambdaman4が解けてしまい完全にこれが答えであること確信。  
乱択に使う乱数生成は実装が単純な方がいいので線形合同法を選択する。係数を探しにウィキペディアを見たところ next = (48271 * x) % (2 << 31 - 1) という定数項がいらない設定があったので、コードゴルフに有利ということでこれを採択。  
なんでこれでいいかを冷静に考えてみると、modが（メルセンヌ）素数で48271がおそらく原始根であるから周期が最大になっているのだろうということに気が付き、同じ条件を満たすパラメータであれば小さいほうがコードが縮むことを発見した。あとはプログラム書いてぶん回し。具体的な生成器のコードはosakが異常コードゴルフで縮めてたのでよく知りません。

## Efficiency
- 1: ソースコードを実行すると当然のように停止しないが、コードを読むと4倍しているコードを22回適用しているのではい
- 2: なんかでかいループが回っていそうだがその結果に0をかけていることを発見。このあたりで読解ゲーであることに気がつく
いくつか読んだけど自分で解かなかったのもある。7-11のSATソルバー使うやつとか。

# kawatea
## spaceship

マスターズ（https://atcoder.jp/contests/masters2024-final）の壁も風もないものっぽかったので、次の頂点にぴったり止まる移動をする貪欲を書く

問題文を読み直すと順番は固定でないことに気づいたので、入力を座標でソートしてみる

順番をさらに改善するために、貪欲での距離をコストとしたTSPを求める

よりよい知見を得るために小さい問題を手で遊んでみると、順番がうまく決まっていれば数手ずつ間を埋めていくと解けるものが多そうに見える

TSPの順番に対して、どこまで訪れたかと今の速度を状態とし、次の頂点に動くのを遷移としたビームサーチを書く
移動の仕方は5手くらいまでのコマンドを全探索する

訪れる順番を固定せずに、これまで訪れた頂点をフラグとして持ったヴァージョンも試してみるが、あまり変わらない

大きな問題は頂点間の距離が大きくてこれで解けないものが多いので、遷移を1コマンドとしたビームサーチも書く

微妙にベストに届いてない問題がいくつかあり、TSPの順番が最善ではなさそうだったので、順番をちょっとかえる焼きなましを書く
焼きなましの遷移は、1頂点を違うところに移す、連続する1区間の頂点列を違うところに移す、連続する1区間の頂点列を逆順にするの3種類

ビームサーチや焼きなましのパラメータをいじりつつひたすらぶん回す

# kenkoooo
## efficiency

- 出てくるコードを見てみると、不動点コンビネータで再帰関数を作っているやつ
- 7, 8 は「各ビット同士の論理式（たくさん）を満たす最小の x を求める」みたいな問題に落ちるので、SAT シルバーで解ける
- ↑は2進数の各桁の関係だったが、9-11は9進数の各桁の論理式を解く。9彩色問題になる（後で聞いたら数独だったらしい）ので、LPソルバーに突っ込む。

# mkut
## 3d1
ループが必要だが、親切なことにExampleにTime Warp を使ったループの仕方とループの抜け方で説明されているので同じことをするだけ。

## 3d2
最初は比較がなくて無理では？って思ったけどinputの範囲が小さいので、Aか-Aになる値を0から順番に試せばOK  
途中A\*sign(A)という解法も生まれたが最終的にはこの解法に帰ってきた。

## 3d3
3d2から-Aのルートなら\*0-1、Aのルートなら\*0+1、0なら0を出すようにすれば通る。  
2日目起きてきたら奇数ならA%2が答えになるという天才的発想が生えていたのでそれを詰めていった。  
ゼロ除算で死なないことに最後まで気づかなかった。

## 3d4
AとBをインクリメントし続けてもう一方になったら答え。  
綺麗に並べたらbest解だったらしい

## 3d5
A\*B/GCD(A,B)をするだけ。  
0で割らないようにするのが難しかったが不要だった。

## 3d6
2から順番に試し割りするだけ。最初に書いたコードが順位が良かったからかなり長い間放置していたが、他の問題が無理すぎてなんとなく数分でちょっと弄ったのがbest解になった。

## 3d7
n進数をスタックとみなして、入れ直しても変わらないなら回文。

## 3d8
3d7をループさせるだけだが、定数の10を書いていたところを更新しないといけないので、サブルーチンの記法（※）を編み出して、値の更新に利用した。  
※ 周期を他より短くし、入力を#で比較して、実行時に入力を元の値に戻ようにすると、ほかのプログラムを動かさずに1回だけ実行される。

## 3d9
後ろから見て)が来たら+1、(が来たら-1する。途中で-1になったらNG。最後まで読んで0になってたらOK。

## 3d10
スタックを使えば終わりだったが、最初は（同じ括弧が連続した回数のスタック、スタックの先頭の文字）を頑張って更新していたため地獄だった。

## 3d11
盤面をメモリとして扱う方法を考えたが、readが大変なので諦め（実際に試すとプログラムがデカすぎてTLEするっぽい）  
200\*200の座標を訪れた回数を記録する100^(200\*200)までの整数にエンコードする方法を試したが、最大ケースの20kステップでTLEするので没（リミットは1Mステップ）。  
訪れた座標のスタックをもって、挿入時にO(N)かけて重複挿入しないようにする方針にすると整数が(200\*200)^100までになって計算が早くなる？のか通った。  
とりあえず通すのが目的だったので、これだけ配置を詰めたりはしていない。

## 3d12
一見ヤバそうだが、テイラー展開するだけ。  
最初誤差全く許容されないと思っていろいろこねくり回していたが、誤差1許容されることに気づいたので、適当に99倍して最後に99割ればOKだった。  
3回目スコアを2割ぐらい削ったのに順位が変わらなかったのを見て大きい問題を詰めるのはやめた。

## efficiency5
efficiency13がなんか見てたら解けたと言われたので、やり始めた。  
JS互換のフォーマットに変換するプログラムを使って、それをweb上のprettierに投げると読める形になるので読むと10^6より大きい最小のメルセンヌ素数を求めているっぽいのでググって提出

## efficiency6
同上

## efficiency12
同上、だが出てきたプログラムが謎の関数（素因数分解して、合成数なら各素因数に対して\*(p-1)/pして+1する）だったので頭の中は？？？だったがやってみたら通った。

# osak
## 初日
とりあえずブラウザで動く通信機を書く。  
後々使いそうなのでRustでICFPのインタプリタを書く。ラムダに渡した式の束縛をきちんと管理できておらず無限にハマっていた。朝6時過ぎに完成したけど、その頃にはとっくにechoで式を評価させるテクが発見されていたので無用の長物になった。 

Lambdamanは素直にコードゴルフでとっつきやすそうなので、こんなんRun Length Encodingに決まってるでしょ（コードゴルフ頻出）と思って簡易アセンブラを作り、(文字)(繰り返し数)のRLEでyuustiのgreedy解を縮めたらそこそこいい感じになる。それを叩き台に改良が進んでいき、最終的にはN要素の文字列辞書＋N進数エンコーディングで落ち着いた。

長いパターンを繰り返してだいたい全体が埋まる経路を作っておいて、取りこぼしはタイミングのいいところで拾いに行く感じにすると最強の辞書圧縮が完成するのでは……と思って議論するも、何を探索すればいいのかいまいちまとまらない（発想自体は最後に迷路を解くアイデアで役に立った）。そうこうしていたらamylaseがランダムウォークでlambdaman 4と5を解いたと言い出して一気に流れが変わる。

## lambdaman8
初期解：最初がDDLLUUUURRRR、一周するごとにDLURがそれぞれ2個ずつ増えていくのでナイーブに s1 + s2 + f (DD+s1+LL) (UU+s2+RR) の再帰を書く。200Bくらい？  
壁にぶつかってもいいし、DLの最中にURが混ざらなければ変なことにはならないので s + (f (DL+s+UR)) の形の再帰にする。～138B  
よく考えると最長部分を通れるパターンを1つ生成して適当に繰り返せばいい。累乗イディオムにすれば終了判定もいらないので再帰より短くできる。116B

## lambdaman16
ヒルベルト曲線というやつ。実装したことはなかったけど図を描いて考えると  
（左上を解く）→ちょっと下に移動→（左下を解く）→ちょっと右に移動→（右下を解く）→ちょっと上に移動→（右上を解く）  
という形になっていて、再帰的にやる部分では対角要素どうしが入れ替わったり入れ替わらなかったりする形になることが分かる。  
そのまま再帰で実装して264B。あとで縮めようと思ったらベストが乱数っぽい長さになっていて諦めた。

## lambdaman19
前に進む→（左手方向を解いて戻ってくる）→（右手方向を解いて戻ってくる）→（正面方向を解いて戻ってくる）→戻るの再帰。346B  
最初の実装では間違って深さを2倍にしてしまっていたけどそれでもなんか解けてた。  
これのベストは乱数じゃなさそうなのでもっとゴルフ頑張ってもよかったかも。

## 乱数
初期解：現在のステップ数と前回の乱数を渡すナイーブな再帰。160Bくらい？  
→ ステップ数ではなく乱数の値で終了判定していいことに気付いて縮む。136B。確率が絡むインチキのつもりだったけど、乱数だと思っていたやつが実は巨大な巡回群だったのでインチキじゃなかった（ということを終わってから聞いた）。  
→ 定数の桁数を減らせればコードも縮むね……ということをyuustiと話していたらいつの間にかamylaseが実装していた。  
→ Lfはローカル変数の導入と等価なんだから、よく考えれば自己再帰はLf B$ vf vfで済むはずなのにYコンビネータはなんか明らかに長い……と思ってこの形にしたら普通に縮んだ。  
→ "solve lambdamanX " + (IF (終了条件) THEN "" ELSE "ULDR"[rand()%4] + (再帰))の形でTHENが空白なのなんか無駄っぽくない？と思って睨んでいたら、再帰の向きを逆順にすることで演算を節約できることに気付く。 (IF (終了条件) THEN "solve lambdamanX " ELSE (再帰) + "ULDR"[rand()%4]) の形になって縮む。この形だと再帰深さを変えると出力の先頭が変わるので探索がしにくいが、amylaseが頑張って探索を直す。でも巡回群なので実は逆元を掛けるだけで乱数を逆順にたどれたらしい（とiwiwiさんが言っていた）。 

## 迷路
解ける乱数は見つかってなかったが、おおよそ解ける乱数というのは結構見つかっていたので、ランダムウォーク中の特定のステップでUUDDのような文字列を挟むことでランダムウォークを壊さずに好きなマスを通過させられるというアイデアをamylaseに話す。そしたら実装してくれた。

# yuusti
## Lambdaman
DFS書いたあとどうすればいいかわからなくて一生困ってた。  
真面目にやるならTSPかと思ったけど書きたくなかったので、迷路だけでも良くできないかと思って単純なアルゴリズムで解けないか右手法的なのを考えてたけど壁からのフィードバックがないのでどうにもならなさそうという結論になった。  
パターンの繰り返しで小さいのくらいはなんとかなるかと思ってパターン長12程度までを全部調べたけど無理だったので諦めた。  

Lambdamanを諦めた後はLambdamanの手動解や3dの小さいケースの改善をやってた。

## 3d1
階乗の計算。A\*(A-1)+...を1\*2\*...にしてA=1,2は直接判定をねじ込んだ

## 3d3
符号を出すやつ。1か-1になるまで/2する方針と(A+1)%2+A%2を計算する方針があって前者を詰めてたけど後者が正解だったらしい  
例外条件としてA=0をチェックしてるところを上書きしてA=-1の判定に使った

## 3d4
AとBの最大値判定。A+1とB+1をそれぞれやってたのをAとBを交換しながら片方ずつインクリメントするようにしたら小さくなった

## 3d5
AとBのLCM。他の人の解から消せそうなTimeWarp削ってこねくり回したらちょっと縮んだ。ユークリッドの互除法で出てきた0を足すことで終了してたのを、あらかじめ置いたSを動かす演算子を上書きする形にしたのが工夫

